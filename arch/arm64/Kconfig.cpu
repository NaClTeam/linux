# SPDX-License-Identifier: GPL-2.0-only
menu "ARM errata workarounds via the alternatives framework"

config AMPERE_ERRATUM_AC03_CPU_38
        bool "AmpereOne: AC03_CPU_38: Certain bits in the Virtualization Translation Control Register and Translation Control Registers do not follow RES0 semantics"
	default y
	help
	  This option adds an alternative code sequence to work around Ampere
	  erratum AC03_CPU_38 on AmpereOne.

	  The affected design reports FEAT_HAFDBS as not implemented in
	  ID_AA64MMFR1_EL1.HAFDBS, but (V)TCR_ELx.{HA,HD} are not RES0
	  as required by the architecture. The unadvertised HAFDBS
	  implementation suffers from an additional erratum where hardware
	  A/D updates can occur after a PTE has been marked invalid.

	  The workaround forces KVM to explicitly set VTCR_EL2.HA to 0,
	  which avoids enabling unadvertised hardware Access Flag management
	  at stage-2.

	  If unsure, say Y.

config ARM64_WORKAROUND_CLEAN_CACHE
	bool

config ARM64_ERRATUM_826319
	bool "Cortex-A53: 826319: System might deadlock if a write cannot complete until read data is accepted"
	default y
	select ARM64_WORKAROUND_CLEAN_CACHE
	help
	  This option adds an alternative code sequence to work around ARM
	  erratum 826319 on Cortex-A53 parts up to r0p2 with an AMBA 4 ACE or
	  AXI master interface and an L2 cache.

	  If a Cortex-A53 uses an AMBA AXI4 ACE interface to other processors
	  and is unable to accept a certain write via this interface, it will
	  not progress on read data presented on the read data channel and the
	  system can deadlock.

	  The workaround promotes data cache clean instructions to
	  data cache clean-and-invalidate.
	  Please note that this does not necessarily enable the workaround,
	  as it depends on the alternative framework, which will only patch
	  the kernel if an affected CPU is detected.

	  If unsure, say Y.

config ARM64_ERRATUM_827319
	bool "Cortex-A53: 827319: Data cache clean instructions might cause overlapping transactions to the interconnect"
	default y
	select ARM64_WORKAROUND_CLEAN_CACHE
	help
	  This option adds an alternative code sequence to work around ARM
	  erratum 827319 on Cortex-A53 parts up to r0p2 with an AMBA 5 CHI
	  master interface and an L2 cache.

	  Under certain conditions this erratum can cause a clean line eviction
	  to occur at the same time as another transaction to the same address
	  on the AMBA 5 CHI interface, which can cause data corruption if the
	  interconnect reorders the two transactions.

	  The workaround promotes data cache clean instructions to
	  data cache clean-and-invalidate.
	  Please note that this does not necessarily enable the workaround,
	  as it depends on the alternative framework, which will only patch
	  the kernel if an affected CPU is detected.

	  If unsure, say Y.

config ARM64_ERRATUM_824069
	bool "Cortex-A53: 824069: Cache line might not be marked as clean after a CleanShared snoop"
	default y
	select ARM64_WORKAROUND_CLEAN_CACHE
	help
	  This option adds an alternative code sequence to work around ARM
	  erratum 824069 on Cortex-A53 parts up to r0p2 when it is connected
	  to a coherent interconnect.

	  If a Cortex-A53 processor is executing a store or prefetch for
	  write instruction at the same time as a processor in another
	  cluster is executing a cache maintenance operation to the same
	  address, then this erratum might cause a clean cache line to be
	  incorrectly marked as dirty.

	  The workaround promotes data cache clean instructions to
	  data cache clean-and-invalidate.
	  Please note that this option does not necessarily enable the
	  workaround, as it depends on the alternative framework, which will
	  only patch the kernel if an affected CPU is detected.

	  If unsure, say Y.

config ARM64_ERRATUM_819472
	bool "Cortex-A53: 819472: Store exclusive instructions might cause data corruption"
	default y
	select ARM64_WORKAROUND_CLEAN_CACHE
	help
	  This option adds an alternative code sequence to work around ARM
	  erratum 819472 on Cortex-A53 parts up to r0p1 with an L2 cache
	  present when it is connected to a coherent interconnect.

	  If the processor is executing a load and store exclusive sequence at
	  the same time as a processor in another cluster is executing a cache
	  maintenance operation to the same address, then this erratum might
	  cause data corruption.

	  The workaround promotes data cache clean instructions to
	  data cache clean-and-invalidate.
	  Please note that this does not necessarily enable the workaround,
	  as it depends on the alternative framework, which will only patch
	  the kernel if an affected CPU is detected.

	  If unsure, say Y.

config ARM64_ERRATUM_832075
	bool "Cortex-A57: 832075: possible deadlock on mixing exclusive memory accesses with device loads"
	default y
	help
	  This option adds an alternative code sequence to work around ARM
	  erratum 832075 on Cortex-A57 parts up to r1p2.

	  Affected Cortex-A57 parts might deadlock when exclusive load/store
	  instructions to Write-Back memory are mixed with Device loads.

	  The workaround is to promote device loads to use Load-Acquire
	  semantics.
	  Please note that this does not necessarily enable the workaround,
	  as it depends on the alternative framework, which will only patch
	  the kernel if an affected CPU is detected.

	  If unsure, say Y.

config ARM64_ERRATUM_834220
	bool "Cortex-A57: 834220: Stage 2 translation fault might be incorrectly reported in presence of a Stage 1 fault (rare)"
	depends on KVM
	help
	  This option adds an alternative code sequence to work around ARM
	  erratum 834220 on Cortex-A57 parts up to r1p2.

	  Affected Cortex-A57 parts might report a Stage 2 translation
	  fault as the result of a Stage 1 fault for load crossing a
	  page boundary when there is a permission or device memory
	  alignment fault at Stage 1 and a translation fault at Stage 2.

	  The workaround is to verify that the Stage 1 translation
	  doesn't generate a fault before handling the Stage 2 fault.
	  Please note that this does not necessarily enable the workaround,
	  as it depends on the alternative framework, which will only patch
	  the kernel if an affected CPU is detected.

	  If unsure, say N.

config ARM64_ERRATUM_1742098
	bool "Cortex-A57/A72: 1742098: ELR recorded incorrectly on interrupt taken between cryptographic instructions in a sequence"
	depends on COMPAT
	default y
	help
	  This option removes the AES hwcap for aarch32 user-space to
	  workaround erratum 1742098 on Cortex-A57 and Cortex-A72.

	  Affected parts may corrupt the AES state if an interrupt is
	  taken between a pair of AES instructions. These instructions
	  are only present if the cryptography extensions are present.
	  All software should have a fallback implementation for CPUs
	  that don't implement the cryptography extensions.

	  If unsure, say Y.

config ARM64_ERRATUM_845719
	bool "Cortex-A53: 845719: a load might read incorrect data"
	depends on COMPAT
	default y
	help
	  This option adds an alternative code sequence to work around ARM
	  erratum 845719 on Cortex-A53 parts up to r0p4.

	  When running a compat (AArch32) userspace on an affected Cortex-A53
	  part, a load at EL0 from a virtual address that matches the bottom 32
	  bits of the virtual address used by a recent load at (AArch64) EL1
	  might return incorrect data.

	  The workaround is to write the contextidr_el1 register on exception
	  return to a 32-bit task.
	  Please note that this does not necessarily enable the workaround,
	  as it depends on the alternative framework, which will only patch
	  the kernel if an affected CPU is detected.

	  If unsure, say Y.

config ARM64_ERRATUM_843419
	bool "Cortex-A53: 843419: A load or store might access an incorrect address"
	default y
	help
	  This option links the kernel with '--fix-cortex-a53-843419' and
	  enables PLT support to replace certain ADRP instructions, which can
	  cause subsequent memory accesses to use an incorrect address on
	  Cortex-A53 parts up to r0p4.

	  If unsure, say Y.

config ARM64_LD_HAS_FIX_ERRATUM_843419
	def_bool $(ld-option,--fix-cortex-a53-843419)

config ARM64_ERRATUM_1024718
	bool "Cortex-A55: 1024718: Update of DBM/AP bits without break before make might result in incorrect update"
	default y
	help
	  This option adds a workaround for ARM Cortex-A55 Erratum 1024718.

	  Affected Cortex-A55 cores (all revisions) could cause incorrect
	  update of the hardware dirty bit when the DBM/AP bits are updated
	  without a break-before-make. The workaround is to disable the usage
	  of hardware DBM locally on the affected cores. CPUs not affected by
	  this erratum will continue to use the feature.

	  If unsure, say Y.

config ARM64_ERRATUM_1418040
	bool "Cortex-A76/Neoverse-N1: MRC read following MRRC read of specific Generic Timer in AArch32 might give incorrect result"
	default y
	depends on COMPAT
	help
	  This option adds a workaround for ARM Cortex-A76/Neoverse-N1
	  errata 1188873 and 1418040.

	  Affected Cortex-A76/Neoverse-N1 cores (r0p0 to r3p1) could
	  cause register corruption when accessing the timer registers
	  from AArch32 userspace.

	  If unsure, say Y.

config ARM64_WORKAROUND_SPECULATIVE_AT
	bool

config ARM64_ERRATUM_1165522
	bool "Cortex-A76: 1165522: Speculative AT instruction using out-of-context translation regime could cause subsequent request to generate an incorrect translation"
	default y
	select ARM64_WORKAROUND_SPECULATIVE_AT
	help
	  This option adds a workaround for ARM Cortex-A76 erratum 1165522.

	  Affected Cortex-A76 cores (r0p0, r1p0, r2p0) could end-up with
	  corrupted TLBs by speculating an AT instruction during a guest
	  context switch.

	  If unsure, say Y.

config ARM64_ERRATUM_1319367
	bool "Cortex-A57/A72: 1319537: Speculative AT instruction using out-of-context translation regime could cause subsequent request to generate an incorrect translation"
	default y
	select ARM64_WORKAROUND_SPECULATIVE_AT
	help
	  This option adds work arounds for ARM Cortex-A57 erratum 1319537
	  and A72 erratum 1319367

	  Cortex-A57 and A72 cores could end-up with corrupted TLBs by
	  speculating an AT instruction during a guest context switch.

	  If unsure, say Y.

config ARM64_ERRATUM_1530923
	bool "Cortex-A55: 1530923: Speculative AT instruction using out-of-context translation regime could cause subsequent request to generate an incorrect translation"
	default y
	select ARM64_WORKAROUND_SPECULATIVE_AT
	help
	  This option adds a workaround for ARM Cortex-A55 erratum 1530923.

	  Affected Cortex-A55 cores (r0p0, r0p1, r1p0, r2p0) could end-up with
	  corrupted TLBs by speculating an AT instruction during a guest
	  context switch.

	  If unsure, say Y.

config ARM64_WORKAROUND_REPEAT_TLBI
	bool

config ARM64_ERRATUM_2441007
	bool "Cortex-A55: Completion of affected memory accesses might not be guaranteed by completion of a TLBI (rare)"
	select ARM64_WORKAROUND_REPEAT_TLBI
	help
	  This option adds a workaround for ARM Cortex-A55 erratum #2441007.

	  Under very rare circumstances, affected Cortex-A55 CPUs
	  may not handle a race between a break-before-make sequence on one
	  CPU, and another CPU accessing the same page. This could allow a
	  store to a page that has been unmapped.

	  Work around this by adding the affected CPUs to the list that needs
	  TLB sequences to be done twice.

	  If unsure, say N.

config ARM64_ERRATUM_1286807
	bool "Cortex-A76: Modification of the translation table for a virtual address might lead to read-after-read ordering violation (rare)"
	select ARM64_WORKAROUND_REPEAT_TLBI
	help
	  This option adds a workaround for ARM Cortex-A76 erratum 1286807.

	  On the affected Cortex-A76 cores (r0p0 to r3p0), if a virtual
	  address for a cacheable mapping of a location is being
	  accessed by a core while another core is remapping the virtual
	  address to a new physical page using the recommended
	  break-before-make sequence, then under very rare circumstances
	  TLBI+DSB completes before a read using the translation being
	  invalidated has been observed by other observers. The
	  workaround repeats the TLBI+DSB operation.

	  If unsure, say N.

config ARM64_ERRATUM_1463225
	bool "Cortex-A76: Software Step might prevent interrupt recognition"
	default y
	help
	  This option adds a workaround for Arm Cortex-A76 erratum 1463225.

	  On the affected Cortex-A76 cores (r0p0 to r3p1), software stepping
	  of a system call instruction (SVC) can prevent recognition of
	  subsequent interrupts when software stepping is disabled in the
	  exception handler of the system call and either kernel debugging
	  is enabled or VHE is in use.

	  Work around the erratum by triggering a dummy step exception
	  when handling a system call from a task that is being stepped
	  in a VHE configuration of the kernel.

	  If unsure, say Y.

config ARM64_ERRATUM_1542419
	bool "Neoverse-N1: workaround mis-ordering of instruction fetches (rare)"
	help
	  This option adds a workaround for ARM Neoverse-N1 erratum
	  1542419.

	  Affected Neoverse-N1 cores could execute a stale instruction when
	  modified by another CPU. The workaround depends on a firmware
	  counterpart.

	  Workaround the issue by hiding the DIC feature from EL0. This
	  forces user-space to perform cache maintenance.

	  If unsure, say N.

config ARM64_ERRATUM_1508412
	bool "Cortex-A77: 1508412: workaround deadlock on sequence of NC/Device load and store exclusive or PAR read"
	default y
	help
	  This option adds a workaround for Arm Cortex-A77 erratum 1508412.

	  Affected Cortex-A77 cores (r0p0, r1p0) could deadlock on a sequence
	  of a store-exclusive or read of PAR_EL1 and a load with device or
	  non-cacheable memory attributes. The workaround depends on a firmware
	  counterpart.

	  KVM guests must also have the workaround implemented or they can
	  deadlock the system.

	  Work around the issue by inserting DMB SY barriers around PAR_EL1
	  register reads and warning KVM users. The DMB barrier is sufficient
	  to prevent a speculative PAR_EL1 read.

	  If unsure, say Y.

config ARM64_WORKAROUND_TRBE_OVERWRITE_FILL_MODE
	bool

config ARM64_ERRATUM_2051678
	bool "Cortex-A510: 2051678: disable Hardware Update of the page table dirty bit"
	default y
	help
	  This options adds the workaround for ARM Cortex-A510 erratum ARM64_ERRATUM_2051678.
	  Affected Cortex-A510 might not respect the ordering rules for
	  hardware update of the page table's dirty bit. The workaround
	  is to not enable the feature on affected CPUs.

	  If unsure, say Y.

config ARM64_ERRATUM_2077057
	bool "Cortex-A510: 2077057: workaround software-step corrupting SPSR_EL2"
	default y
	help
	  This option adds the workaround for ARM Cortex-A510 erratum 2077057.
	  Affected Cortex-A510 may corrupt SPSR_EL2 when the a step exception is
	  expected, but a Pointer Authentication trap is taken instead. The
	  erratum causes SPSR_EL1 to be copied to SPSR_EL2, which could allow
	  EL1 to cause a return to EL2 with a guest controlled ELR_EL2.

	  This can only happen when EL2 is stepping EL1.

	  When these conditions occur, the SPSR_EL2 value is unchanged from the
	  previous guest entry, and can be restored from the in-memory copy.

	  If unsure, say Y.

config ARM64_ERRATUM_2658417
	bool "Cortex-A510: 2658417: remove BF16 support due to incorrect result"
	default y
	help
	  This option adds the workaround for ARM Cortex-A510 erratum 2658417.
	  Affected Cortex-A510 (r0p0 to r1p1) may produce the wrong result for
	  BFMMLA or VMMLA instructions in rare circumstances when a pair of
	  A510 CPUs are using shared neon hardware. As the sharing is not
	  discoverable by the kernel, hide the BF16 HWCAP to indicate that
	  user-space should not be using these instructions.

	  If unsure, say Y.

config ARM64_ERRATUM_2119858
	bool "Cortex-A710/X2: 2119858: workaround TRBE overwriting trace data in FILL mode"
	default y
	depends on CORESIGHT_TRBE
	select ARM64_WORKAROUND_TRBE_OVERWRITE_FILL_MODE
	help
	  This option adds the workaround for ARM Cortex-A710/X2 erratum 2119858.

	  Affected Cortex-A710/X2 cores could overwrite up to 3 cache lines of trace
	  data at the base of the buffer (pointed to by TRBASER_EL1) in FILL mode in
	  the event of a WRAP event.

	  Work around the issue by always making sure we move the TRBPTR_EL1 by
	  256 bytes before enabling the buffer and filling the first 256 bytes of
	  the buffer with ETM ignore packets upon disabling.

	  If unsure, say Y.

config ARM64_ERRATUM_2139208
	bool "Neoverse-N2: 2139208: workaround TRBE overwriting trace data in FILL mode"
	default y
	depends on CORESIGHT_TRBE
	select ARM64_WORKAROUND_TRBE_OVERWRITE_FILL_MODE
	help
	  This option adds the workaround for ARM Neoverse-N2 erratum 2139208.

	  Affected Neoverse-N2 cores could overwrite up to 3 cache lines of trace
	  data at the base of the buffer (pointed to by TRBASER_EL1) in FILL mode in
	  the event of a WRAP event.

	  Work around the issue by always making sure we move the TRBPTR_EL1 by
	  256 bytes before enabling the buffer and filling the first 256 bytes of
	  the buffer with ETM ignore packets upon disabling.

	  If unsure, say Y.

config ARM64_WORKAROUND_TSB_FLUSH_FAILURE
	bool

config ARM64_ERRATUM_2054223
	bool "Cortex-A710: 2054223: workaround TSB instruction failing to flush trace"
	default y
	select ARM64_WORKAROUND_TSB_FLUSH_FAILURE
	help
	  Enable workaround for ARM Cortex-A710 erratum 2054223

	  Affected cores may fail to flush the trace data on a TSB instruction, when
	  the PE is in trace prohibited state. This will cause losing a few bytes
	  of the trace cached.

	  Workaround is to issue two TSB consecutively on affected cores.

	  If unsure, say Y.

config ARM64_ERRATUM_2067961
	bool "Neoverse-N2: 2067961: workaround TSB instruction failing to flush trace"
	default y
	select ARM64_WORKAROUND_TSB_FLUSH_FAILURE
	help
	  Enable workaround for ARM Neoverse-N2 erratum 2067961

	  Affected cores may fail to flush the trace data on a TSB instruction, when
	  the PE is in trace prohibited state. This will cause losing a few bytes
	  of the trace cached.

	  Workaround is to issue two TSB consecutively on affected cores.

	  If unsure, say Y.

config ARM64_WORKAROUND_TRBE_WRITE_OUT_OF_RANGE
	bool

config ARM64_ERRATUM_2253138
	bool "Neoverse-N2: 2253138: workaround TRBE writing to address out-of-range"
	depends on CORESIGHT_TRBE
	default y
	select ARM64_WORKAROUND_TRBE_WRITE_OUT_OF_RANGE
	help
	  This option adds the workaround for ARM Neoverse-N2 erratum 2253138.

	  Affected Neoverse-N2 cores might write to an out-of-range address, not reserved
	  for TRBE. Under some conditions, the TRBE might generate a write to the next
	  virtually addressed page following the last page of the TRBE address space
	  (i.e., the TRBLIMITR_EL1.LIMIT), instead of wrapping around to the base.

	  Work around this in the driver by always making sure that there is a
	  page beyond the TRBLIMITR_EL1.LIMIT, within the space allowed for the TRBE.

	  If unsure, say Y.

config ARM64_ERRATUM_2224489
	bool "Cortex-A710/X2: 2224489: workaround TRBE writing to address out-of-range"
	depends on CORESIGHT_TRBE
	default y
	select ARM64_WORKAROUND_TRBE_WRITE_OUT_OF_RANGE
	help
	  This option adds the workaround for ARM Cortex-A710/X2 erratum 2224489.

	  Affected Cortex-A710/X2 cores might write to an out-of-range address, not reserved
	  for TRBE. Under some conditions, the TRBE might generate a write to the next
	  virtually addressed page following the last page of the TRBE address space
	  (i.e., the TRBLIMITR_EL1.LIMIT), instead of wrapping around to the base.

	  Work around this in the driver by always making sure that there is a
	  page beyond the TRBLIMITR_EL1.LIMIT, within the space allowed for the TRBE.

	  If unsure, say Y.

config ARM64_ERRATUM_2441009
	bool "Cortex-A510: Completion of affected memory accesses might not be guaranteed by completion of a TLBI (rare)"
	select ARM64_WORKAROUND_REPEAT_TLBI
	help
	  This option adds a workaround for ARM Cortex-A510 erratum #2441009.

	  Under very rare circumstances, affected Cortex-A510 CPUs
	  may not handle a race between a break-before-make sequence on one
	  CPU, and another CPU accessing the same page. This could allow a
	  store to a page that has been unmapped.

	  Work around this by adding the affected CPUs to the list that needs
	  TLB sequences to be done twice.

	  If unsure, say N.

config ARM64_ERRATUM_2064142
	bool "Cortex-A510: 2064142: workaround TRBE register writes while disabled"
	depends on CORESIGHT_TRBE
	default y
	help
	  This option adds the workaround for ARM Cortex-A510 erratum 2064142.

	  Affected Cortex-A510 core might fail to write into system registers after the
	  TRBE has been disabled. Under some conditions after the TRBE has been disabled
	  writes into TRBE registers TRBLIMITR_EL1, TRBPTR_EL1, TRBBASER_EL1, TRBSR_EL1,
	  and TRBTRG_EL1 will be ignored and will not be effected.

	  Work around this in the driver by executing TSB CSYNC and DSB after collection
	  is stopped and before performing a system register write to one of the affected
	  registers.

	  If unsure, say Y.

config ARM64_ERRATUM_2038923
	bool "Cortex-A510: 2038923: workaround TRBE corruption with enable"
	depends on CORESIGHT_TRBE
	default y
	help
	  This option adds the workaround for ARM Cortex-A510 erratum 2038923.

	  Affected Cortex-A510 core might cause an inconsistent view on whether trace is
	  prohibited within the CPU. As a result, the trace buffer or trace buffer state
	  might be corrupted. This happens after TRBE buffer has been enabled by setting
	  TRBLIMITR_EL1.E, followed by just a single context synchronization event before
	  execution changes from a context, in which trace is prohibited to one where it
	  isn't, or vice versa. In these mentioned conditions, the view of whether trace
	  is prohibited is inconsistent between parts of the CPU, and the trace buffer or
	  the trace buffer state might be corrupted.

	  Work around this in the driver by preventing an inconsistent view of whether the
	  trace is prohibited or not based on TRBLIMITR_EL1.E by immediately following a
	  change to TRBLIMITR_EL1.E with at least one ISB instruction before an ERET, or
	  two ISB instructions if no ERET is to take place.

	  If unsure, say Y.

config ARM64_ERRATUM_1902691
	bool "Cortex-A510: 1902691: workaround TRBE trace corruption"
	depends on CORESIGHT_TRBE
	default y
	help
	  This option adds the workaround for ARM Cortex-A510 erratum 1902691.

	  Affected Cortex-A510 core might cause trace data corruption, when being written
	  into the memory. Effectively TRBE is broken and hence cannot be used to capture
	  trace data.

	  Work around this problem in the driver by just preventing TRBE initialization on
	  affected cpus. The firmware must have disabled the access to TRBE for the kernel
	  on such implementations. This will cover the kernel for any firmware that doesn't
	  do this already.

	  If unsure, say Y.

config ARM64_ERRATUM_2457168
	bool "Cortex-A510: 2457168: workaround for AMEVCNTR01 incrementing incorrectly"
	depends on ARM64_AMU_EXTN
	default y
	help
	  This option adds the workaround for ARM Cortex-A510 erratum 2457168.

	  The AMU counter AMEVCNTR01 (constant counter) should increment at the same rate
	  as the system counter. On affected Cortex-A510 cores AMEVCNTR01 increments
	  incorrectly giving a significantly higher output value.

	  Work around this problem by returning 0 when reading the affected counter in
	  key locations that results in disabling all users of this counter. This effect
	  is the same to firmware disabling affected counters.

	  If unsure, say Y.

config ARM64_ERRATUM_2645198
	bool "Cortex-A715: 2645198: Workaround possible [ESR|FAR]_ELx corruption"
	default y
	help
	  This option adds the workaround for ARM Cortex-A715 erratum 2645198.

	  If a Cortex-A715 cpu sees a page mapping permissions change from executable
	  to non-executable, it may corrupt the ESR_ELx and FAR_ELx registers on the
	  next instruction abort caused by permission fault.

	  Only user-space does executable to non-executable permission transition via
	  mprotect() system call. Workaround the problem by doing a break-before-make
	  TLB invalidation, for all changes to executable user space mappings.

	  If unsure, say Y.

config ARM64_WORKAROUND_SPECULATIVE_UNPRIV_LOAD
	bool

config ARM64_ERRATUM_2966298
	bool "Cortex-A520: 2966298: workaround for speculatively executed unprivileged load"
	select ARM64_WORKAROUND_SPECULATIVE_UNPRIV_LOAD
	default y
	help
	  This option adds the workaround for ARM Cortex-A520 erratum 2966298.

	  On an affected Cortex-A520 core, a speculatively executed unprivileged
	  load might leak data from a privileged level via a cache side channel.

	  Work around this problem by executing a TLBI before returning to EL0.

	  If unsure, say Y.

config ARM64_ERRATUM_3117295
	bool "Cortex-A510: 3117295: workaround for speculatively executed unprivileged load"
	select ARM64_WORKAROUND_SPECULATIVE_UNPRIV_LOAD
	default y
	help
	  This option adds the workaround for ARM Cortex-A510 erratum 3117295.

	  On an affected Cortex-A510 core, a speculatively executed unprivileged
	  load might leak data from a privileged level via a cache side channel.

	  Work around this problem by executing a TLBI before returning to EL0.

	  If unsure, say Y.

config CAVIUM_ERRATUM_22375
	bool "Cavium erratum 22375, 24313"
	default y
	help
	  Enable workaround for errata 22375 and 24313.

	  This implements two gicv3-its errata workarounds for ThunderX. Both
	  with a small impact affecting only ITS table allocation.

	    erratum 22375: only alloc 8MB table size
	    erratum 24313: ignore memory access type

	  The fixes are in ITS initialization and basically ignore memory access
	  type and table size provided by the TYPER and BASER registers.

	  If unsure, say Y.

config CAVIUM_ERRATUM_23144
	bool "Cavium erratum 23144: ITS SYNC hang on dual socket system"
	depends on NUMA
	default y
	help
	  ITS SYNC command hang for cross node io and collections/cpu mapping.

	  If unsure, say Y.

config CAVIUM_ERRATUM_23154
	bool "Cavium errata 23154 and 38545: GICv3 lacks HW synchronisation"
	default y
	help
	  The ThunderX GICv3 implementation requires a modified version for
	  reading the IAR status to ensure data synchronization
	  (access to icc_iar1_el1 is not sync'ed before and after).

	  It also suffers from erratum 38545 (also present on Marvell's
	  OcteonTX and OcteonTX2), resulting in deactivated interrupts being
	  spuriously presented to the CPU interface.

	  If unsure, say Y.

config CAVIUM_ERRATUM_27456
	bool "Cavium erratum 27456: Broadcast TLBI instructions may cause icache corruption"
	default y
	help
	  On ThunderX T88 pass 1.x through 2.1 parts, broadcast TLBI
	  instructions may cause the icache to become corrupted if it
	  contains data for a non-current ASID.  The fix is to
	  invalidate the icache when changing the mm context.

	  If unsure, say Y.

config CAVIUM_ERRATUM_30115
	bool "Cavium erratum 30115: Guest may disable interrupts in host"
	default y
	help
	  On ThunderX T88 pass 1.x through 2.2, T81 pass 1.0 through
	  1.2, and T83 Pass 1.0, KVM guest execution may disable
	  interrupts in host. Trapping both GICv3 group-0 and group-1
	  accesses sidesteps the issue.

	  If unsure, say Y.

config CAVIUM_TX2_ERRATUM_219
	bool "Cavium ThunderX2 erratum 219: PRFM between TTBR change and ISB fails"
	default y
	help
	  On Cavium ThunderX2, a load, store or prefetch instruction between a
	  TTBR update and the corresponding context synchronizing operation can
	  cause a spurious Data Abort to be delivered to any hardware thread in
	  the CPU core.

	  Work around the issue by avoiding the problematic code sequence and
	  trapping KVM guest TTBRx_EL1 writes to EL2 when SMT is enabled. The
	  trap handler performs the corresponding register access, skips the
	  instruction and ensures context synchronization by virtue of the
	  exception return.

	  If unsure, say Y.

config FUJITSU_ERRATUM_010001
	bool "Fujitsu-A64FX erratum E#010001: Undefined fault may occur wrongly"
	default y
	help
	  This option adds a workaround for Fujitsu-A64FX erratum E#010001.
	  On some variants of the Fujitsu-A64FX cores ver(1.0, 1.1), memory
	  accesses may cause undefined fault (Data abort, DFSC=0b111111).
	  This fault occurs under a specific hardware condition when a
	  load/store instruction performs an address translation using:
	  case-1  TTBR0_EL1 with TCR_EL1.NFD0 == 1.
	  case-2  TTBR0_EL2 with TCR_EL2.NFD0 == 1.
	  case-3  TTBR1_EL1 with TCR_EL1.NFD1 == 1.
	  case-4  TTBR1_EL2 with TCR_EL2.NFD1 == 1.

	  The workaround is to ensure these bits are clear in TCR_ELx.
	  The workaround only affects the Fujitsu-A64FX.

	  If unsure, say Y.

config HISILICON_ERRATUM_161600802
	bool "Hip07 161600802: Erroneous redistributor VLPI base"
	default y
	help
	  The HiSilicon Hip07 SoC uses the wrong redistributor base
	  when issued ITS commands such as VMOVP and VMAPP, and requires
	  a 128kB offset to be applied to the target address in this commands.

	  If unsure, say Y.

config QCOM_FALKOR_ERRATUM_1003
	bool "Falkor E1003: Incorrect translation due to ASID change"
	default y
	help
	  On Falkor v1, an incorrect ASID may be cached in the TLB when ASID
	  and BADDR are changed together in TTBRx_EL1. Since we keep the ASID
	  in TTBR1_EL1, this situation only occurs in the entry trampoline and
	  then only for entries in the walk cache, since the leaf translation
	  is unchanged. Work around the erratum by invalidating the walk cache
	  entries for the trampoline before entering the kernel proper.

config QCOM_FALKOR_ERRATUM_1009
	bool "Falkor E1009: Prematurely complete a DSB after a TLBI"
	default y
	select ARM64_WORKAROUND_REPEAT_TLBI
	help
	  On Falkor v1, the CPU may prematurely complete a DSB following a
	  TLBI xxIS invalidate maintenance operation. Repeat the TLBI operation
	  one more time to fix the issue.

	  If unsure, say Y.

config QCOM_QDF2400_ERRATUM_0065
	bool "QDF2400 E0065: Incorrect GITS_TYPER.ITT_Entry_size"
	default y
	help
	  On Qualcomm Datacenter Technologies QDF2400 SoC, ITS hardware reports
	  ITE size incorrectly. The GITS_TYPER.ITT_Entry_size field should have
	  been indicated as 16Bytes (0xf), not 8Bytes (0x7).

	  If unsure, say Y.

config QCOM_FALKOR_ERRATUM_E1041
	bool "Falkor E1041: Speculative instruction fetches might cause errant memory access"
	default y
	help
	  Falkor CPU may speculatively fetch instructions from an improper
	  memory location when MMU translation is changed from SCTLR_ELn[M]=1
	  to SCTLR_ELn[M]=0. Prefix an ISB instruction to fix the problem.

	  If unsure, say Y.

config NVIDIA_CARMEL_CNP_ERRATUM
	bool "NVIDIA Carmel CNP: CNP on Carmel semantically different than ARM cores"
	default y
	help
	  If CNP is enabled on Carmel cores, non-sharable TLBIs on a core will not
	  invalidate shared TLB entries installed by a different core, as it would
	  on standard ARM cores.

	  If unsure, say Y.

config ROCKCHIP_ERRATUM_3588001
	bool "Rockchip 3588001: GIC600 can not support shareability attributes"
	default y
	help
	  The Rockchip RK3588 GIC600 SoC integration does not support ACE/ACE-lite.
	  This means, that its sharability feature may not be used, even though it
	  is supported by the IP itself.

	  If unsure, say Y.

config SOCIONEXT_SYNQUACER_PREITS
	bool "Socionext Synquacer: Workaround for GICv3 pre-ITS"
	default y
	help
	  Socionext Synquacer SoCs implement a separate h/w block to generate
	  MSI doorbell writes with non-zero values for the device ID.

	  If unsure, say Y.

endmenu # "ARM errata workarounds via the alternatives framework"

menu "ARMv8.1 architectural features"

config ARM64_HW_AFDBM
	bool "Support for hardware updates of the Access and Dirty page flags"
	default y
	help
	  The ARMv8.1 architecture extensions introduce support for
	  hardware updates of the access and dirty information in page
	  table entries. When enabled in TCR_EL1 (HA and HD bits) on
	  capable processors, accesses to pages with PTE_AF cleared will
	  set this bit instead of raising an access flag fault.
	  Similarly, writes to read-only pages with the DBM bit set will
	  clear the read-only bit (AP[2]) instead of raising a
	  permission fault.

	  Kernels built with this configuration option enabled continue
	  to work on pre-ARMv8.1 hardware and the performance impact is
	  minimal. If unsure, say Y.

config ARM64_PAN
	bool "Enable support for Privileged Access Never (PAN)"
	default y
	help
	  Privileged Access Never (PAN; part of the ARMv8.1 Extensions)
	  prevents the kernel or hypervisor from accessing user-space (EL0)
	  memory directly.

	  Choosing this option will cause any unprotected (not using
	  copy_to_user et al) memory access to fail with a permission fault.

	  The feature is detected at runtime, and will remain as a 'nop'
	  instruction if the cpu does not implement the feature.

config AS_HAS_LSE_ATOMICS
	def_bool $(as-instr,.arch_extension lse)

config ARM64_LSE_ATOMICS
	bool
	default ARM64_USE_LSE_ATOMICS
	depends on AS_HAS_LSE_ATOMICS

config ARM64_USE_LSE_ATOMICS
	bool "Atomic instructions"
	default y
	help
	  As part of the Large System Extensions, ARMv8.1 introduces new
	  atomic instructions that are designed specifically to scale in
	  very large systems.

	  Say Y here to make use of these instructions for the in-kernel
	  atomic routines. This incurs a small overhead on CPUs that do
	  not support these instructions and requires the kernel to be
	  built with binutils >= 2.25 in order for the new instructions
	  to be used.

endmenu # "ARMv8.1 architectural features"

menu "ARMv8.2 architectural features"

config AS_HAS_ARMV8_2
	def_bool $(cc-option,-Wa$(comma)-march=armv8.2-a)

config AS_HAS_SHA3
	def_bool $(as-instr,.arch armv8.2-a+sha3)

config ARM64_PMEM
	bool "Enable support for persistent memory"
	select ARCH_HAS_PMEM_API
	select ARCH_HAS_UACCESS_FLUSHCACHE
	help
	  Say Y to enable support for the persistent memory API based on the
	  ARMv8.2 DCPoP feature.

	  The feature is detected at runtime, and the kernel will use DC CVAC
	  operations if DC CVAP is not supported (following the behaviour of
	  DC CVAP itself if the system does not define a point of persistence).

config ARM64_RAS_EXTN
	bool "Enable support for RAS CPU Extensions"
	default y
	help
	  CPUs that support the Reliability, Availability and Serviceability
	  (RAS) Extensions, part of ARMv8.2 are able to track faults and
	  errors, classify them and report them to software.

	  On CPUs with these extensions system software can use additional
	  barriers to determine if faults are pending and read the
	  classification from a new set of registers.

	  Selecting this feature will allow the kernel to use these barriers
	  and access the new registers if the system supports the extension.
	  Platform RAS features may additionally depend on firmware support.

config ARM64_CNP
	bool "Enable support for Common Not Private (CNP) translations"
	default y
	depends on ARM64_PAN || !ARM64_SW_TTBR0_PAN
	help
	  Common Not Private (CNP) allows translation table entries to
	  be shared between different PEs in the same inner shareable
	  domain, so the hardware can use this fact to optimise the
	  caching of such entries in the TLB.

	  Selecting this option allows the CNP feature to be detected
	  at runtime, and does not affect PEs that do not implement
	  this feature.

endmenu # "ARMv8.2 architectural features"

menu "ARMv8.3 architectural features"

config ARM64_PTR_AUTH
	bool "Enable support for pointer authentication"
	default y
	help
	  Pointer authentication (part of the ARMv8.3 Extensions) provides
	  instructions for signing and authenticating pointers against secret
	  keys, which can be used to mitigate Return Oriented Programming (ROP)
	  and other attacks.

	  This option enables these instructions at EL0 (i.e. for userspace).
	  Choosing this option will cause the kernel to initialise secret keys
	  for each process at exec() time, with these keys being
	  context-switched along with the process.

	  The feature is detected at runtime. If the feature is not present in
	  hardware it will not be advertised to userspace/KVM guest nor will it
	  be enabled.

	  If the feature is present on the boot CPU but not on a late CPU, then
	  the late CPU will be parked. Also, if the boot CPU does not have
	  address auth and the late CPU has then the late CPU will still boot
	  but with the feature disabled. On such a system, this option should
	  not be selected.

config ARM64_PTR_AUTH_KERNEL
	bool "Use pointer authentication for kernel"
	default y
	depends on ARM64_PTR_AUTH
	depends on (CC_HAS_SIGN_RETURN_ADDRESS || CC_HAS_BRANCH_PROT_PAC_RET) && AS_HAS_ARMV8_3
	# Modern compilers insert a .note.gnu.property section note for PAC
	# which is only understood by binutils starting with version 2.33.1.
	depends on LD_IS_LLD || LD_VERSION >= 23301 || (CC_IS_GCC && GCC_VERSION < 90100)
	depends on !CC_IS_CLANG || AS_HAS_CFI_NEGATE_RA_STATE
	depends on (!FUNCTION_GRAPH_TRACER || DYNAMIC_FTRACE_WITH_ARGS)
	help
	  If the compiler supports the -mbranch-protection or
	  -msign-return-address flag (e.g. GCC 7 or later), then this option
	  will cause the kernel itself to be compiled with return address
	  protection. In this case, and if the target hardware is known to
	  support pointer authentication, then CONFIG_STACKPROTECTOR can be
	  disabled with minimal loss of protection.

	  This feature works with FUNCTION_GRAPH_TRACER option only if
	  DYNAMIC_FTRACE_WITH_ARGS is enabled.

config CC_HAS_BRANCH_PROT_PAC_RET
	# GCC 9 or later, clang 8 or later
	def_bool $(cc-option,-mbranch-protection=pac-ret+leaf)

config CC_HAS_SIGN_RETURN_ADDRESS
	# GCC 7, 8
	def_bool $(cc-option,-msign-return-address=all)

config AS_HAS_ARMV8_3
	def_bool $(cc-option,-Wa$(comma)-march=armv8.3-a)

config AS_HAS_CFI_NEGATE_RA_STATE
	def_bool $(as-instr,.cfi_startproc\n.cfi_negate_ra_state\n.cfi_endproc\n)

config AS_HAS_LDAPR
	def_bool $(as-instr,.arch_extension rcpc)

endmenu # "ARMv8.3 architectural features"

menu "ARMv8.4 architectural features"

config ARM64_AMU_EXTN
	bool "Enable support for the Activity Monitors Unit CPU extension"
	default y
	help
	  The activity monitors extension is an optional extension introduced
	  by the ARMv8.4 CPU architecture. This enables support for version 1
	  of the activity monitors architecture, AMUv1.

	  To enable the use of this extension on CPUs that implement it, say Y.

	  Note that for architectural reasons, firmware _must_ implement AMU
	  support when running on CPUs that present the activity monitors
	  extension. The required support is present in:
	    * Version 1.5 and later of the ARM Trusted Firmware

	  For kernels that have this configuration enabled but boot with broken
	  firmware, you may need to say N here until the firmware is fixed.
	  Otherwise you may experience firmware panics or lockups when
	  accessing the counter registers. Even if you are not observing these
	  symptoms, the values returned by the register reads might not
	  correctly reflect reality. Most commonly, the value read will be 0,
	  indicating that the counter is not enabled.

config AS_HAS_ARMV8_4
	def_bool $(cc-option,-Wa$(comma)-march=armv8.4-a)

config ARM64_TLB_RANGE
	bool "Enable support for tlbi range feature"
	default y
	depends on AS_HAS_ARMV8_4
	help
	  ARMv8.4-TLBI provides TLBI invalidation instruction that apply to a
	  range of input addresses.

	  The feature introduces new assembly instructions, and they were
	  support when binutils >= 2.30.

endmenu # "ARMv8.4 architectural features"

menu "ARMv8.5 architectural features"

config AS_HAS_ARMV8_5
	def_bool $(cc-option,-Wa$(comma)-march=armv8.5-a)

config ARM64_BTI
	bool "Branch Target Identification support"
	default y
	help
	  Branch Target Identification (part of the ARMv8.5 Extensions)
	  provides a mechanism to limit the set of locations to which computed
	  branch instructions such as BR or BLR can jump.

	  To make use of BTI on CPUs that support it, say Y.

	  BTI is intended to provide complementary protection to other control
	  flow integrity protection mechanisms, such as the Pointer
	  authentication mechanism provided as part of the ARMv8.3 Extensions.
	  For this reason, it does not make sense to enable this option without
	  also enabling support for pointer authentication.  Thus, when
	  enabling this option you should also select ARM64_PTR_AUTH=y.

	  Userspace binaries must also be specifically compiled to make use of
	  this mechanism.  If you say N here or the hardware does not support
	  BTI, such binaries can still run, but you get no additional
	  enforcement of branch destinations.

config ARM64_BTI_KERNEL
	bool "Use Branch Target Identification for kernel"
	default y
	depends on ARM64_BTI
	depends on ARM64_PTR_AUTH_KERNEL
	depends on CC_HAS_BRANCH_PROT_PAC_RET_BTI
	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94697
	depends on !CC_IS_GCC || GCC_VERSION >= 100100
	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106671
	depends on !CC_IS_GCC
	depends on (!FUNCTION_GRAPH_TRACER || DYNAMIC_FTRACE_WITH_ARGS)
	help
	  Build the kernel with Branch Target Identification annotations
	  and enable enforcement of this for kernel code. When this option
	  is enabled and the system supports BTI all kernel code including
	  modular code must have BTI enabled.

config CC_HAS_BRANCH_PROT_PAC_RET_BTI
	# GCC 9 or later, clang 8 or later
	def_bool $(cc-option,-mbranch-protection=pac-ret+leaf+bti)

config ARM64_E0PD
	bool "Enable support for E0PD"
	default y
	help
	  E0PD (part of the ARMv8.5 extensions) allows us to ensure
	  that EL0 accesses made via TTBR1 always fault in constant time,
	  providing similar benefits to KASLR as those provided by KPTI, but
	  with lower overhead and without disrupting legitimate access to
	  kernel memory such as SPE.

	  This option enables E0PD for TTBR1 where available.

config ARM64_AS_HAS_MTE
	# Initial support for MTE went in binutils 2.32.0, checked with
	# ".arch armv8.5-a+memtag" below. However, this was incomplete
	# as a late addition to the final architecture spec (LDGM/STGM)
	# is only supported in the newer 2.32.x and 2.33 binutils
	# versions, hence the extra "stgm" instruction check below.
	def_bool $(as-instr,.arch armv8.5-a+memtag\nstgm xzr$(comma)[x0])

config ARM64_MTE
	bool "Memory Tagging Extension support"
	default y
	depends on ARM64_AS_HAS_MTE && ARM64_TAGGED_ADDR_ABI
	depends on AS_HAS_ARMV8_5
	depends on AS_HAS_LSE_ATOMICS
	# Required for tag checking in the uaccess routines
	depends on ARM64_PAN
	select ARCH_HAS_SUBPAGE_FAULTS
	select ARCH_USES_HIGH_VMA_FLAGS
	select ARCH_USES_PG_ARCH_X
	help
	  Memory Tagging (part of the ARMv8.5 Extensions) provides
	  architectural support for run-time, always-on detection of
	  various classes of memory error to aid with software debugging
	  to eliminate vulnerabilities arising from memory-unsafe
	  languages.

	  This option enables the support for the Memory Tagging
	  Extension at EL0 (i.e. for userspace).

	  Selecting this option allows the feature to be detected at
	  runtime. Any secondary CPU not implementing this feature will
	  not be allowed a late bring-up.

	  Userspace binaries that want to use this feature must
	  explicitly opt in. The mechanism for the userspace is
	  described in:

	  Documentation/arch/arm64/memory-tagging-extension.rst.

endmenu # "ARMv8.5 architectural features"

menu "ARMv8.7 architectural features"

config ARM64_EPAN
	bool "Enable support for Enhanced Privileged Access Never (EPAN)"
	default y
	depends on ARM64_PAN
	help
	  Enhanced Privileged Access Never (EPAN) allows Privileged
	  Access Never to be used with Execute-only mappings.

	  The feature is detected at runtime, and will remain disabled
	  if the cpu does not implement the feature.
endmenu # "ARMv8.7 architectural features"

config ARM64_SVE
	bool "ARM Scalable Vector Extension support"
	default y
	help
	  The Scalable Vector Extension (SVE) is an extension to the AArch64
	  execution state which complements and extends the SIMD functionality
	  of the base architecture to support much larger vectors and to enable
	  additional vectorisation opportunities.

	  To enable use of this extension on CPUs that implement it, say Y.

	  On CPUs that support the SVE2 extensions, this option will enable
	  those too.

	  Note that for architectural reasons, firmware _must_ implement SVE
	  support when running on SVE capable hardware.  The required support
	  is present in:

	    * version 1.5 and later of the ARM Trusted Firmware
	    * the AArch64 boot wrapper since commit 5e1261e08abf
	      ("bootwrapper: SVE: Enable SVE for EL2 and below").

	  For other firmware implementations, consult the firmware documentation
	  or vendor.

	  If you need the kernel to boot on SVE-capable hardware with broken
	  firmware, you may need to say N here until you get your firmware
	  fixed.  Otherwise, you may experience firmware panics or lockups when
	  booting the kernel.  If unsure and you are not observing these
	  symptoms, you should assume that it is safe to say Y.

config ARM64_SME
	bool "ARM Scalable Matrix Extension support"
	default y
	depends on ARM64_SVE
	help
	  The Scalable Matrix Extension (SME) is an extension to the AArch64
	  execution state which utilises a substantial subset of the SVE
	  instruction set, together with the addition of new architectural
	  register state capable of holding two dimensional matrix tiles to
	  enable various matrix operations.
