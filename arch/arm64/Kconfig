# SPDX-License-Identifier: GPL-2.0-only
config ARM64
	def_bool y
	select ACPI_APMT if ACPI
	select ACPI_CCA_REQUIRED if ACPI
	select ACPI_GENERIC_GSI if ACPI
	select ACPI_GTDT if ACPI
	select ACPI_IORT if ACPI
	select ACPI_REDUCED_HARDWARE_ONLY if ACPI
	select ACPI_MCFG if (ACPI && PCI)
	select ACPI_SPCR_TABLE if ACPI
	select ACPI_PPTT if ACPI
	select ARCH_HAS_DEBUG_WX
	select ARCH_BINFMT_ELF_EXTRA_PHDRS
	select ARCH_BINFMT_ELF_STATE
	select ARCH_CORRECT_STACKTRACE_ON_KRETPROBE
	select ARCH_ENABLE_HUGEPAGE_MIGRATION if HUGETLB_PAGE && MIGRATION
	select ARCH_ENABLE_MEMORY_HOTPLUG
	select ARCH_ENABLE_MEMORY_HOTREMOVE
	select ARCH_ENABLE_SPLIT_PMD_PTLOCK if PGTABLE_LEVELS > 2
	select ARCH_ENABLE_THP_MIGRATION if TRANSPARENT_HUGEPAGE
	select ARCH_HAS_CACHE_LINE_SIZE
	select ARCH_HAS_CURRENT_STACK_POINTER
	select ARCH_HAS_DEBUG_VIRTUAL
	select ARCH_HAS_DEBUG_VM_PGTABLE
	select ARCH_HAS_DMA_PREP_COHERENT
	select ARCH_HAS_ACPI_TABLE_UPGRADE if ACPI
	select ARCH_HAS_FAST_MULTIPLIER
	select ARCH_HAS_FORTIFY_SOURCE
	select ARCH_HAS_GCOV_PROFILE_ALL
	select ARCH_HAS_GIGANTIC_PAGE
	select ARCH_HAS_KCOV
	select ARCH_HAS_KEEPINITRD
	select ARCH_HAS_MEMBARRIER_SYNC_CORE
	select ARCH_HAS_NMI_SAFE_THIS_CPU_OPS
	select ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE
	select ARCH_HAS_PTE_DEVMAP
	select ARCH_HAS_PTE_SPECIAL
	select ARCH_HAS_HW_PTE_YOUNG
	select ARCH_HAS_SETUP_DMA_OPS
	select ARCH_HAS_SET_DIRECT_MAP
	select ARCH_HAS_SET_MEMORY
	select ARCH_STACKWALK
	select ARCH_HAS_STRICT_KERNEL_RWX
	select ARCH_HAS_STRICT_MODULE_RWX
	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
	select ARCH_HAS_SYNC_DMA_FOR_CPU
	select ARCH_HAS_SYSCALL_WRAPPER
	select ARCH_HAS_TEARDOWN_DMA_OPS if IOMMU_SUPPORT
	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
	select ARCH_HAS_ZONE_DMA_SET if EXPERT
	select ARCH_HAVE_ELF_PROT
	select ARCH_HAVE_NMI_SAFE_CMPXCHG
	select ARCH_HAVE_TRACE_MMIO_ACCESS
	select ARCH_INLINE_READ_LOCK if !PREEMPTION
	select ARCH_INLINE_READ_LOCK_BH if !PREEMPTION
	select ARCH_INLINE_READ_LOCK_IRQ if !PREEMPTION
	select ARCH_INLINE_READ_LOCK_IRQSAVE if !PREEMPTION
	select ARCH_INLINE_READ_UNLOCK if !PREEMPTION
	select ARCH_INLINE_READ_UNLOCK_BH if !PREEMPTION
	select ARCH_INLINE_READ_UNLOCK_IRQ if !PREEMPTION
	select ARCH_INLINE_READ_UNLOCK_IRQRESTORE if !PREEMPTION
	select ARCH_INLINE_WRITE_LOCK if !PREEMPTION
	select ARCH_INLINE_WRITE_LOCK_BH if !PREEMPTION
	select ARCH_INLINE_WRITE_LOCK_IRQ if !PREEMPTION
	select ARCH_INLINE_WRITE_LOCK_IRQSAVE if !PREEMPTION
	select ARCH_INLINE_WRITE_UNLOCK if !PREEMPTION
	select ARCH_INLINE_WRITE_UNLOCK_BH if !PREEMPTION
	select ARCH_INLINE_WRITE_UNLOCK_IRQ if !PREEMPTION
	select ARCH_INLINE_WRITE_UNLOCK_IRQRESTORE if !PREEMPTION
	select ARCH_INLINE_SPIN_TRYLOCK if !PREEMPTION
	select ARCH_INLINE_SPIN_TRYLOCK_BH if !PREEMPTION
	select ARCH_INLINE_SPIN_LOCK if !PREEMPTION
	select ARCH_INLINE_SPIN_LOCK_BH if !PREEMPTION
	select ARCH_INLINE_SPIN_LOCK_IRQ if !PREEMPTION
	select ARCH_INLINE_SPIN_LOCK_IRQSAVE if !PREEMPTION
	select ARCH_INLINE_SPIN_UNLOCK if !PREEMPTION
	select ARCH_INLINE_SPIN_UNLOCK_BH if !PREEMPTION
	select ARCH_INLINE_SPIN_UNLOCK_IRQ if !PREEMPTION
	select ARCH_INLINE_SPIN_UNLOCK_IRQRESTORE if !PREEMPTION
	select ARCH_KEEP_MEMBLOCK
	select ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE
	select ARCH_USE_CMPXCHG_LOCKREF
	select ARCH_USE_GNU_PROPERTY
	select ARCH_USE_MEMTEST
	select ARCH_USE_QUEUED_RWLOCKS
	select ARCH_USE_QUEUED_SPINLOCKS
	select ARCH_USE_SYM_ANNOTATIONS
	select ARCH_SUPPORTS_DEBUG_PAGEALLOC
	select ARCH_SUPPORTS_HUGETLBFS
	select ARCH_SUPPORTS_MEMORY_FAILURE
	select ARCH_SUPPORTS_SHADOW_CALL_STACK if CC_HAVE_SHADOW_CALL_STACK
	select ARCH_SUPPORTS_LTO_CLANG if CPU_LITTLE_ENDIAN
	select ARCH_SUPPORTS_LTO_CLANG_THIN
	select ARCH_SUPPORTS_CFI_CLANG
	select ARCH_SUPPORTS_ATOMIC_RMW
	select ARCH_SUPPORTS_INT128 if CC_HAS_INT128
	select ARCH_SUPPORTS_NUMA_BALANCING
	select ARCH_SUPPORTS_PAGE_TABLE_CHECK
	select ARCH_SUPPORTS_PER_VMA_LOCK
	select ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH
	select ARCH_WANT_COMPAT_IPC_PARSE_VERSION if COMPAT
	select ARCH_WANT_DEFAULT_BPF_JIT
	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT
	select ARCH_WANT_FRAME_POINTERS
	select ARCH_WANT_HUGE_PMD_SHARE if ARM64_4K_PAGES || (ARM64_16K_PAGES && !ARM64_VA_BITS_36)
	select ARCH_WANT_LD_ORPHAN_WARN
	select ARCH_WANTS_NO_INSTR
	select ARCH_WANTS_THP_SWAP if ARM64_4K_PAGES
	select ARCH_HAS_UBSAN
	select ARM_AMBA
	select ARM_ARCH_TIMER
	select ARM_GIC
	select AUDIT_ARCH_COMPAT_GENERIC
	select ARM_GIC_V2M if PCI
	select ARM_GIC_V3
	select ARM_GIC_V3_ITS if PCI
	select ARM_PSCI_FW
	select BUILDTIME_TABLE_SORT
	select CLONE_BACKWARDS
	select COMMON_CLK
	select CPU_PM if (SUSPEND || CPU_IDLE)
	select CRC32
	select DCACHE_WORD_ACCESS
	select DYNAMIC_FTRACE if FUNCTION_TRACER
	select DMA_BOUNCE_UNALIGNED_KMALLOC
	select DMA_DIRECT_REMAP
	select EDAC_SUPPORT
	select FRAME_POINTER
	select FUNCTION_ALIGNMENT_4B
	select FUNCTION_ALIGNMENT_8B if DYNAMIC_FTRACE_WITH_CALL_OPS
	select GENERIC_ALLOCATOR
	select GENERIC_ARCH_TOPOLOGY
	select GENERIC_CLOCKEVENTS_BROADCAST
	select GENERIC_CPU_AUTOPROBE
	select GENERIC_CPU_DEVICES
	select GENERIC_CPU_VULNERABILITIES
	select GENERIC_EARLY_IOREMAP
	select GENERIC_IDLE_POLL_SETUP
	select GENERIC_IOREMAP
	select GENERIC_IRQ_IPI
	select GENERIC_IRQ_PROBE
	select GENERIC_IRQ_SHOW
	select GENERIC_IRQ_SHOW_LEVEL
	select GENERIC_LIB_DEVMEM_IS_ALLOWED
	select GENERIC_PCI_IOMAP
	select GENERIC_PTDUMP
	select GENERIC_SCHED_CLOCK
	select GENERIC_SMP_IDLE_THREAD
	select GENERIC_TIME_VSYSCALL
	select GENERIC_GETTIMEOFDAY
	select GENERIC_VDSO_TIME_NS
	select HARDIRQS_SW_RESEND
	select HAS_IOPORT
	select HAVE_MOVE_PMD
	select HAVE_MOVE_PUD
	select HAVE_PCI
	select HAVE_ACPI_APEI if (ACPI && EFI)
	select HAVE_ALIGNED_STRUCT_PAGE
	select HAVE_ARCH_AUDITSYSCALL
	select HAVE_ARCH_BITREVERSE
	select HAVE_ARCH_COMPILER_H
	select HAVE_ARCH_HUGE_VMALLOC
	select HAVE_ARCH_HUGE_VMAP
	select HAVE_ARCH_JUMP_LABEL
	select HAVE_ARCH_JUMP_LABEL_RELATIVE
	select HAVE_ARCH_KASAN
	select HAVE_ARCH_KASAN_VMALLOC if HAVE_ARCH_KASAN
	select HAVE_ARCH_KASAN_SW_TAGS if HAVE_ARCH_KASAN
	select HAVE_ARCH_KASAN_HW_TAGS if (HAVE_ARCH_KASAN && ARM64_MTE)
	# Some instrumentation may be unsound, hence EXPERT
	select HAVE_ARCH_KCSAN if EXPERT
	select HAVE_ARCH_KFENCE
	select HAVE_ARCH_KGDB
	select HAVE_ARCH_MMAP_RND_BITS
	select HAVE_ARCH_MMAP_RND_COMPAT_BITS if COMPAT
	select HAVE_ARCH_PREL32_RELOCATIONS
	select HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET
	select HAVE_ARCH_SECCOMP_FILTER
	select HAVE_ARCH_STACKLEAK
	select HAVE_ARCH_THREAD_STRUCT_WHITELIST
	select HAVE_ARCH_TRACEHOOK
	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
	select HAVE_ARCH_VMAP_STACK
	select HAVE_ARM_SMCCC
	select HAVE_ASM_MODVERSIONS
	select HAVE_EBPF_JIT
	select HAVE_C_RECORDMCOUNT
	select HAVE_CMPXCHG_DOUBLE
	select HAVE_CMPXCHG_LOCAL
	select HAVE_CONTEXT_TRACKING_USER
	select HAVE_DEBUG_KMEMLEAK
	select HAVE_DMA_CONTIGUOUS
	select HAVE_DYNAMIC_FTRACE
	select HAVE_DYNAMIC_FTRACE_WITH_ARGS \
		if $(cc-option,-fpatchable-function-entry=2)
	select HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS \
		if DYNAMIC_FTRACE_WITH_ARGS && DYNAMIC_FTRACE_WITH_CALL_OPS
	select HAVE_DYNAMIC_FTRACE_WITH_CALL_OPS \
		if (DYNAMIC_FTRACE_WITH_ARGS && !CFI_CLANG && \
		    (CC_IS_CLANG || !CC_OPTIMIZE_FOR_SIZE))
	select FTRACE_MCOUNT_USE_PATCHABLE_FUNCTION_ENTRY \
		if DYNAMIC_FTRACE_WITH_ARGS
	select HAVE_SAMPLE_FTRACE_DIRECT
	select HAVE_SAMPLE_FTRACE_DIRECT_MULTI
	select HAVE_EFFICIENT_UNALIGNED_ACCESS
	select HAVE_FAST_GUP
	select HAVE_FTRACE_MCOUNT_RECORD
	select HAVE_FUNCTION_TRACER
	select HAVE_FUNCTION_ERROR_INJECTION
	select HAVE_FUNCTION_GRAPH_RETVAL if HAVE_FUNCTION_GRAPH_TRACER
	select HAVE_FUNCTION_GRAPH_TRACER
	select HAVE_GCC_PLUGINS
	select HAVE_HARDLOCKUP_DETECTOR_PERF if PERF_EVENTS && \
		HW_PERF_EVENTS && HAVE_PERF_EVENTS_NMI
	select HAVE_HW_BREAKPOINT if PERF_EVENTS
	select HAVE_IOREMAP_PROT
	select HAVE_IRQ_TIME_ACCOUNTING
	select HAVE_MOD_ARCH_SPECIFIC
	select HAVE_NMI
	select HAVE_PERF_EVENTS
	select HAVE_PERF_EVENTS_NMI if ARM64_PSEUDO_NMI
	select HAVE_PERF_REGS
	select HAVE_PERF_USER_STACK_DUMP
	select HAVE_PREEMPT_DYNAMIC_KEY
	select HAVE_REGS_AND_STACK_ACCESS_API
	select HAVE_POSIX_CPU_TIMERS_TASK_WORK
	select HAVE_FUNCTION_ARG_ACCESS_API
	select MMU_GATHER_RCU_TABLE_FREE
	select HAVE_RSEQ
	select HAVE_RUST if CPU_LITTLE_ENDIAN
	select HAVE_STACKPROTECTOR
	select HAVE_SYSCALL_TRACEPOINTS
	select HAVE_KPROBES
	select HAVE_KRETPROBES
	select HAVE_GENERIC_VDSO
	select HOTPLUG_CORE_SYNC_DEAD if HOTPLUG_CPU
	select IRQ_DOMAIN
	select IRQ_FORCED_THREADING
	select KASAN_VMALLOC if KASAN
	select LOCK_MM_AND_FIND_VMA
	select MODULES_USE_ELF_RELA
	select NEED_DMA_MAP_STATE
	select NEED_SG_DMA_LENGTH
	select OF
	select OF_EARLY_FLATTREE
	select PCI_DOMAINS_GENERIC if PCI
	select PCI_ECAM if (ACPI && PCI)
	select PCI_SYSCALL if PCI
	select POWER_RESET
	select POWER_SUPPLY
	select SPARSE_IRQ
	select SWIOTLB
	select SYSCTL_EXCEPTION_TRACE
	select THREAD_INFO_IN_TASK
	select HAVE_ARCH_USERFAULTFD_MINOR if USERFAULTFD
	select TRACE_IRQFLAGS_SUPPORT
	select TRACE_IRQFLAGS_NMI_SUPPORT
	select HAVE_SOFTIRQ_ON_OWN_STACK
	help
	  ARM 64-bit (AArch64) Linux support.

config CLANG_SUPPORTS_DYNAMIC_FTRACE_WITH_ARGS
	def_bool CC_IS_CLANG
	# https://github.com/ClangBuiltLinux/linux/issues/1507
	depends on AS_IS_GNU || (AS_IS_LLVM && (LD_IS_LLD || LD_VERSION >= 23600))
	select HAVE_DYNAMIC_FTRACE_WITH_ARGS

config GCC_SUPPORTS_DYNAMIC_FTRACE_WITH_ARGS
	def_bool CC_IS_GCC
	depends on $(cc-option,-fpatchable-function-entry=2)
	select HAVE_DYNAMIC_FTRACE_WITH_ARGS

config 64BIT
	def_bool y

config MMU
	def_bool y

config ARM64_PAGE_SHIFT
	int
	default 16 if ARM64_64K_PAGES
	default 14 if ARM64_16K_PAGES
	default 12

config ARM64_CONT_PTE_SHIFT
	int
	default 5 if ARM64_64K_PAGES
	default 7 if ARM64_16K_PAGES
	default 4

config ARM64_CONT_PMD_SHIFT
	int
	default 5 if ARM64_64K_PAGES
	default 5 if ARM64_16K_PAGES
	default 4

config ARCH_MMAP_RND_BITS_MIN
	default 14 if ARM64_64K_PAGES
	default 16 if ARM64_16K_PAGES
	default 18

# max bits determined by the following formula:
#  VA_BITS - PAGE_SHIFT - 3
config ARCH_MMAP_RND_BITS_MAX
	default 19 if ARM64_VA_BITS=36
	default 24 if ARM64_VA_BITS=39
	default 27 if ARM64_VA_BITS=42
	default 30 if ARM64_VA_BITS=47
	default 29 if ARM64_VA_BITS=48 && ARM64_64K_PAGES
	default 31 if ARM64_VA_BITS=48 && ARM64_16K_PAGES
	default 33 if ARM64_VA_BITS=48
	default 14 if ARM64_64K_PAGES
	default 16 if ARM64_16K_PAGES
	default 18

config ARCH_MMAP_RND_COMPAT_BITS_MIN
	default 7 if ARM64_64K_PAGES
	default 9 if ARM64_16K_PAGES
	default 11

config ARCH_MMAP_RND_COMPAT_BITS_MAX
	default 16

config NO_IOPORT_MAP
	def_bool y if !PCI

config STACKTRACE_SUPPORT
	def_bool y

config ILLEGAL_POINTER_VALUE
	hex
	default 0xdead000000000000

config LOCKDEP_SUPPORT
	def_bool y

config GENERIC_BUG
	def_bool y
	depends on BUG

config GENERIC_BUG_RELATIVE_POINTERS
	def_bool y
	depends on GENERIC_BUG

config GENERIC_HWEIGHT
	def_bool y

config GENERIC_CSUM
	def_bool y

config GENERIC_CALIBRATE_DELAY
	def_bool y

config SMP
	def_bool y

config KERNEL_MODE_NEON
	def_bool y

config FIX_EARLYCON_MEM
	def_bool y

config PGTABLE_LEVELS
	int
	default 2 if ARM64_16K_PAGES && ARM64_VA_BITS_36
	default 2 if ARM64_64K_PAGES && ARM64_VA_BITS_42
	default 3 if ARM64_64K_PAGES && (ARM64_VA_BITS_48 || ARM64_VA_BITS_52)
	default 3 if ARM64_4K_PAGES && ARM64_VA_BITS_39
	default 3 if ARM64_16K_PAGES && ARM64_VA_BITS_47
	default 4 if ARM64_16K_PAGES && (ARM64_VA_BITS_48 || ARM64_VA_BITS_52)
	default 4 if !ARM64_64K_PAGES && ARM64_VA_BITS_48
	default 5 if ARM64_4K_PAGES && ARM64_VA_BITS_52

config ARCH_SUPPORTS_UPROBES
	def_bool y

config ARCH_PROC_KCORE_TEXT
	def_bool y

config BROKEN_GAS_INST
	def_bool !$(as-instr,1:\n.inst 0\n.rept . - 1b\n\nnop\n.endr\n)

config BUILTIN_RETURN_ADDRESS_STRIPS_PAC
	bool
	# Clang's __builtin_return_adddress() strips the PAC since 12.0.0
	# https://github.com/llvm/llvm-project/commit/2a96f47c5ffca84cd774ad402cacd137f4bf45e2
	default y if CC_IS_CLANG
	# GCC's __builtin_return_address() strips the PAC since 11.1.0,
	# and this was backported to 10.2.0, 9.4.0, 8.5.0, but not earlier
	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=94891
	default y if CC_IS_GCC && (GCC_VERSION >= 110100)
	default y if CC_IS_GCC && (GCC_VERSION >= 100200) && (GCC_VERSION < 110000)
	default y if CC_IS_GCC && (GCC_VERSION >=  90400) && (GCC_VERSION < 100000)
	default y if CC_IS_GCC && (GCC_VERSION >=  80500) && (GCC_VERSION <  90000)
	default n

config KASAN_SHADOW_OFFSET
	hex
	depends on KASAN_GENERIC || KASAN_SW_TAGS
	default 0xdfff800000000000 if (ARM64_VA_BITS_48 || (ARM64_VA_BITS_52 && !ARM64_16K_PAGES)) && !KASAN_SW_TAGS
	default 0xdfffc00000000000 if (ARM64_VA_BITS_47 || ARM64_VA_BITS_52) && ARM64_16K_PAGES && !KASAN_SW_TAGS
	default 0xdffffe0000000000 if ARM64_VA_BITS_42 && !KASAN_SW_TAGS
	default 0xdfffffc000000000 if ARM64_VA_BITS_39 && !KASAN_SW_TAGS
	default 0xdffffff800000000 if ARM64_VA_BITS_36 && !KASAN_SW_TAGS
	default 0xefff800000000000 if (ARM64_VA_BITS_48 || (ARM64_VA_BITS_52 && !ARM64_16K_PAGES)) && KASAN_SW_TAGS
	default 0xefffc00000000000 if (ARM64_VA_BITS_47 || ARM64_VA_BITS_52) && ARM64_16K_PAGES && KASAN_SW_TAGS
	default 0xeffffe0000000000 if ARM64_VA_BITS_42 && KASAN_SW_TAGS
	default 0xefffffc000000000 if ARM64_VA_BITS_39 && KASAN_SW_TAGS
	default 0xeffffff800000000 if ARM64_VA_BITS_36 && KASAN_SW_TAGS
	default 0xffffffffffffffff

config UNWIND_TABLES
	bool

source "arch/arm64/Kconfig.platforms"

menu "Kernel Features"

source "arch/arm64/Kconfig.cpu"

choice
	prompt "Page size"
	default ARM64_4K_PAGES
	help
	  Page size (translation granule) configuration.

config ARM64_4K_PAGES
	bool "4KB"
	help
	  This feature enables 4KB pages support.

config ARM64_16K_PAGES
	bool "16KB"
	help
	  The system will use 16KB pages support. AArch32 emulation
	  requires applications compiled with 16K (or a multiple of 16K)
	  aligned segments.

config ARM64_64K_PAGES
	bool "64KB"
	help
	  This feature enables 64KB pages support (4KB by default)
	  allowing only two levels of page tables and faster TLB
	  look-up. AArch32 emulation requires applications compiled
	  with 64K aligned segments.

endchoice

choice
	prompt "Virtual address space size"
	default ARM64_VA_BITS_52
	help
	  Allows choosing one of multiple possible virtual address
	  space sizes. The level of translation table is determined by
	  a combination of page size and virtual address space size.

config ARM64_VA_BITS_36
	bool "36-bit" if EXPERT
	depends on ARM64_16K_PAGES

config ARM64_VA_BITS_39
	bool "39-bit"
	depends on ARM64_4K_PAGES

config ARM64_VA_BITS_42
	bool "42-bit"
	depends on ARM64_64K_PAGES

config ARM64_VA_BITS_47
	bool "47-bit"
	depends on ARM64_16K_PAGES

config ARM64_VA_BITS_48
	bool "48-bit"

config ARM64_VA_BITS_52
	bool "52-bit"
	depends on ARM64_PAN || !ARM64_SW_TTBR0_PAN
	help
	  Enable 52-bit virtual addressing for userspace when explicitly
	  requested via a hint to mmap(). The kernel will also use 52-bit
	  virtual addresses for its own mappings (provided HW support for
	  this feature is available, otherwise it reverts to 48-bit).

	  NOTE: Enabling 52-bit virtual addressing in conjunction with
	  ARMv8.3 Pointer Authentication will result in the PAC being
	  reduced from 7 bits to 3 bits, which may have a significant
	  impact on its susceptibility to brute-force attacks.

	  If unsure, select 48-bit virtual addressing instead.

endchoice

config ARM64_FORCE_52BIT
	bool "Force 52-bit virtual addresses for userspace"
	depends on ARM64_VA_BITS_52 && EXPERT
	help
	  For systems with 52-bit userspace VAs enabled, the kernel will attempt
	  to maintain compatibility with older software by providing 48-bit VAs
	  unless a hint is supplied to mmap.

	  This configuration option disables the 48-bit compatibility logic, and
	  forces all userspace addresses to be 52-bit on HW that supports it. One
	  should only enable this configuration option for stress testing userspace
	  memory management code. If unsure say N here.

config ARM64_VA_BITS
	int
	default 36 if ARM64_VA_BITS_36
	default 39 if ARM64_VA_BITS_39
	default 42 if ARM64_VA_BITS_42
	default 47 if ARM64_VA_BITS_47
	default 48 if ARM64_VA_BITS_48
	default 52 if ARM64_VA_BITS_52

choice
	prompt "Physical address space size"
	default ARM64_PA_BITS_48
	help
	  Choose the maximum physical address range that the kernel will
	  support.

config ARM64_PA_BITS_48
	bool "48-bit"
	depends on ARM64_64K_PAGES || !ARM64_VA_BITS_52

config ARM64_PA_BITS_52
	bool "52-bit"
	depends on ARM64_64K_PAGES || ARM64_VA_BITS_52
	depends on ARM64_PAN || !ARM64_SW_TTBR0_PAN
	help
	  Enable support for a 52-bit physical address space, introduced as
	  part of the ARMv8.2-LPA extension.

	  With this enabled, the kernel will also continue to work on CPUs that
	  do not support ARMv8.2-LPA, but with some added memory overhead (and
	  minor performance overhead).

endchoice

config ARM64_PA_BITS
	int
	default 48 if ARM64_PA_BITS_48
	default 52 if ARM64_PA_BITS_52

config ARM64_LPA2
	def_bool y
	depends on ARM64_PA_BITS_52 && !ARM64_64K_PAGES

choice
	prompt "Endianness"
	default CPU_LITTLE_ENDIAN
	help
	  Select the endianness of data accesses performed by the CPU. Userspace
	  applications will need to be compiled and linked for the endianness
	  that is selected here.

config CPU_BIG_ENDIAN
	bool "Build big-endian kernel"
	# https://github.com/llvm/llvm-project/commit/1379b150991f70a5782e9a143c2ba5308da1161c
	depends on AS_IS_GNU || AS_VERSION >= 150000
	help
	  Say Y if you plan on running a kernel with a big-endian userspace.

config CPU_LITTLE_ENDIAN
	bool "Build little-endian kernel"
	help
	  Say Y if you plan on running a kernel with a little-endian userspace.
	  This is usually the case for distributions targeting arm64.

endchoice

config SCHED_MC
	bool "Multi-core scheduler support"
	help
	  Multi-core scheduler support improves the CPU scheduler's decision
	  making when dealing with multi-core CPU chips at a cost of slightly
	  increased overhead in some places. If unsure say N here.

config SCHED_CLUSTER
	bool "Cluster scheduler support"
	help
	  Cluster scheduler support improves the CPU scheduler's decision
	  making when dealing with machines that have clusters of CPUs.
	  Cluster usually means a couple of CPUs which are placed closely
	  by sharing mid-level caches, last-level cache tags or internal
	  busses.

config SCHED_SMT
	bool "SMT scheduler support"
	help
	  Improves the CPU scheduler's decision making when dealing with
	  MultiThreading at a cost of slightly increased overhead in some
	  places. If unsure say N here.

config NR_CPUS
	int "Maximum number of CPUs (2-4096)"
	range 2 4096
	default "256"

config HOTPLUG_CPU
	bool "Support for hot-pluggable CPUs"
	select GENERIC_IRQ_MIGRATION
	help
	  Say Y here to experiment with turning CPUs off and on.  CPUs
	  can be controlled through /sys/devices/system/cpu.

# Common NUMA Features
config NUMA
	bool "NUMA Memory Allocation and Scheduler Support"
	select GENERIC_ARCH_NUMA
	select ACPI_NUMA if ACPI
	select OF_NUMA
	select HAVE_SETUP_PER_CPU_AREA
	select NEED_PER_CPU_EMBED_FIRST_CHUNK
	select NEED_PER_CPU_PAGE_FIRST_CHUNK
	select USE_PERCPU_NUMA_NODE_ID
	help
	  Enable NUMA (Non-Uniform Memory Access) support.

	  The kernel will try to allocate memory used by a CPU on the
	  local memory of the CPU and add some more
	  NUMA awareness to the kernel.

config NODES_SHIFT
	int "Maximum NUMA Nodes (as a power of 2)"
	range 1 10
	default "4"
	depends on NUMA
	help
	  Specify the maximum number of NUMA Nodes available on the target
	  system.  Increases memory reserved to accommodate various tables.

source "kernel/Kconfig.hz"

config ARCH_SPARSEMEM_ENABLE
	def_bool y
	select SPARSEMEM_VMEMMAP_ENABLE
	select SPARSEMEM_VMEMMAP

config HW_PERF_EVENTS
	def_bool y
	depends on ARM_PMU

# Supported by clang >= 7.0 or GCC >= 12.0.0
config CC_HAVE_SHADOW_CALL_STACK
	def_bool $(cc-option, -fsanitize=shadow-call-stack -ffixed-x18)

config PARAVIRT
	bool "Enable paravirtualization code"
	help
	  This changes the kernel so it can modify itself when it is run
	  under a hypervisor, potentially improving performance significantly
	  over full virtualization.

config PARAVIRT_TIME_ACCOUNTING
	bool "Paravirtual steal time accounting"
	select PARAVIRT
	help
	  Select this option to enable fine granularity task steal time
	  accounting. Time spent executing other tasks in parallel with
	  the current vCPU is discounted from the vCPU power. To account for
	  that, there can be a small performance impact.

	  If in doubt, say N here.

config ARCH_SUPPORTS_KEXEC
	def_bool PM_SLEEP_SMP

config ARCH_SUPPORTS_KEXEC_FILE
	def_bool y

config ARCH_SELECTS_KEXEC_FILE
	def_bool y
	depends on KEXEC_FILE
	select HAVE_IMA_KEXEC if IMA

config ARCH_SUPPORTS_KEXEC_SIG
	def_bool y

config ARCH_SUPPORTS_KEXEC_IMAGE_VERIFY_SIG
	def_bool y

config ARCH_DEFAULT_KEXEC_IMAGE_VERIFY_SIG
	def_bool y

config ARCH_SUPPORTS_CRASH_DUMP
	def_bool y

config ARCH_HAS_GENERIC_CRASHKERNEL_RESERVATION
	def_bool CRASH_RESERVE

config TRANS_TABLE
	def_bool y
	depends on HIBERNATION || KEXEC_CORE

config XEN_DOM0
	def_bool y
	depends on XEN

config XEN
	bool "Xen guest support on ARM64"
	depends on ARM64 && OF
	select SWIOTLB_XEN
	select PARAVIRT
	help
	  Say Y if you want to run Linux in a Virtual Machine on Xen on ARM64.

# include/linux/mmzone.h requires the following to be true:
#
#   MAX_PAGE_ORDER + PAGE_SHIFT <= SECTION_SIZE_BITS
#
# so the maximum value of MAX_PAGE_ORDER is SECTION_SIZE_BITS - PAGE_SHIFT:
#
#     | SECTION_SIZE_BITS |  PAGE_SHIFT  |  max MAX_PAGE_ORDER  |  default MAX_PAGE_ORDER |
# ----+-------------------+--------------+----------------------+-------------------------+
# 4K  |       27          |      12      |       15             |         10              |
# 16K |       27          |      14      |       13             |         11              |
# 64K |       29          |      16      |       13             |         13              |
config ARCH_FORCE_MAX_ORDER
	int
	default "13" if ARM64_64K_PAGES
	default "11" if ARM64_16K_PAGES
	default "10"
	help
	  The kernel page allocator limits the size of maximal physically
	  contiguous allocations. The limit is called MAX_PAGE_ORDER and it
	  defines the maximal power of two of number of pages that can be
	  allocated as a single contiguous block. This option allows
	  overriding the default setting when ability to allocate very
	  large blocks of physically contiguous memory is required.

	  The maximal size of allocation cannot exceed the size of the
	  section, so the value of MAX_PAGE_ORDER should satisfy

	    MAX_PAGE_ORDER + PAGE_SHIFT <= SECTION_SIZE_BITS

	  Don't change if unsure.

config UNMAP_KERNEL_AT_EL0
	bool "Unmap kernel when running in userspace (KPTI)" if EXPERT
	default y
	help
	  Speculation attacks against some high-performance processors can
	  be used to bypass MMU permission checks and leak kernel data to
	  userspace. This can be defended against by unmapping the kernel
	  when running in userspace, mapping it back in on exception entry
	  via a trampoline page in the vector table.

	  If unsure, say Y.

config MITIGATE_SPECTRE_BRANCH_HISTORY
	bool "Mitigate Spectre style attacks against branch history" if EXPERT
	default y
	help
	  Speculation attacks against some high-performance processors can
	  make use of branch history to influence future speculation.
	  When taking an exception from user-space, a sequence of branches
	  or a firmware call overwrites the branch history.

config RODATA_FULL_DEFAULT_ENABLED
	bool "Apply r/o permissions of VM areas also to their linear aliases"
	default y
	help
	  Apply read-only attributes of VM areas to the linear alias of
	  the backing pages as well. This prevents code or read-only data
	  from being modified (inadvertently or intentionally) via another
	  mapping of the same memory page. This additional enhancement can
	  be turned off at runtime by passing rodata=[off|on] (and turned on
	  with rodata=full if this option is set to 'n')

	  This requires the linear region to be mapped down to pages,
	  which may adversely affect performance in some cases.

config ARM64_WXN
	bool "Enable WXN attribute so all writable mappings are non-exec"
	help
	  Set the WXN bit in the SCTLR system register so that all writable
	  mappings are treated as if the PXN/UXN bit is set as well.
	  If this is set to Y, it can still be disabled at runtime by
	  passing 'arm64.nowxn' on the kernel command line.

	  This should only be set if no software needs to be supported that
	  relies on being able to execute from writable mappings.

config ARM64_SW_TTBR0_PAN
	bool "Emulate Privileged Access Never using TTBR0_EL1 switching"
	help
	  Enabling this option prevents the kernel from accessing
	  user-space memory directly by pointing TTBR0_EL1 to a reserved
	  zeroed area and reserved ASID. The user access routines
	  restore the valid TTBR0_EL1 temporarily.

config ARM64_TAGGED_ADDR_ABI
	bool "Enable the tagged user addresses syscall ABI"
	default y
	help
	  When this option is enabled, user applications can opt in to a
	  relaxed ABI via prctl() allowing tagged addresses to be passed
	  to system calls as pointer arguments. For details, see
	  Documentation/arch/arm64/tagged-address-abi.rst.

menuconfig COMPAT
	bool "Kernel support for 32-bit EL0"
	depends on ARM64_4K_PAGES || EXPERT
	select HAVE_UID16
	select OLD_SIGSUSPEND3
	select COMPAT_OLD_SIGACTION
	help
	  This option enables support for a 32-bit EL0 running under a 64-bit
	  kernel at EL1. AArch32-specific components such as system calls,
	  the user helper functions, VFP support and the ptrace interface are
	  handled appropriately by the kernel.

	  If you use a page size other than 4KB (i.e, 16KB or 64KB), please be aware
	  that you will only be able to execute AArch32 binaries that were compiled
	  with page size aligned segments.

	  If you want to execute 32-bit userspace applications, say Y.

if COMPAT

config KUSER_HELPERS
	bool "Enable kuser helpers page for 32-bit applications"
	default y
	help
	  Warning: disabling this option may break 32-bit user programs.

	  Provide kuser helpers to compat tasks. The kernel provides
	  helper code to userspace in read only form at a fixed location
	  to allow userspace to be independent of the CPU type fitted to
	  the system. This permits binaries to be run on ARMv4 through
	  to ARMv8 without modification.

	  See Documentation/arch/arm/kernel_user_helpers.rst for details.

	  However, the fixed address nature of these helpers can be used
	  by ROP (return orientated programming) authors when creating
	  exploits.

	  If all of the binaries and libraries which run on your platform
	  are built specifically for your platform, and make no use of
	  these helpers, then you can turn this option off to hinder
	  such exploits. However, in that case, if a binary or library
	  relying on those helpers is run, it will not function correctly.

	  Say N here only if you are absolutely certain that you do not
	  need these helpers; otherwise, the safe option is to say Y.

config COMPAT_VDSO
	bool "Enable vDSO for 32-bit applications"
	depends on !CPU_BIG_ENDIAN
	depends on (CC_IS_CLANG && LD_IS_LLD) || "$(CROSS_COMPILE_COMPAT)" != ""
	select GENERIC_COMPAT_VDSO
	default y
	help
	  Place in the process address space of 32-bit applications an
	  ELF shared object providing fast implementations of gettimeofday
	  and clock_gettime.

	  You must have a 32-bit build of glibc 2.22 or later for programs
	  to seamlessly take advantage of this.

config THUMB2_COMPAT_VDSO
	bool "Compile the 32-bit vDSO for Thumb-2 mode" if EXPERT
	depends on COMPAT_VDSO
	default y
	help
	  Compile the compat vDSO with '-mthumb -fomit-frame-pointer' if y,
	  otherwise with '-marm'.

config COMPAT_ALIGNMENT_FIXUPS
	bool "Fix up misaligned multi-word loads and stores in user space"

menuconfig ARMV8_DEPRECATED
	bool "Emulate deprecated/obsolete ARMv8 instructions"
	depends on SYSCTL
	help
	  Legacy software support may require certain instructions
	  that have been deprecated or obsoleted in the architecture.

	  Enable this config to enable selective emulation of these
	  features.

	  If unsure, say Y

if ARMV8_DEPRECATED

config SWP_EMULATION
	bool "Emulate SWP/SWPB instructions"
	help
	  ARMv8 obsoletes the use of A32 SWP/SWPB instructions such that
	  they are always undefined. Say Y here to enable software
	  emulation of these instructions for userspace using LDXR/STXR.
	  This feature can be controlled at runtime with the abi.swp
	  sysctl which is disabled by default.

	  In some older versions of glibc [<=2.8] SWP is used during futex
	  trylock() operations with the assumption that the code will not
	  be preempted. This invalid assumption may be more likely to fail
	  with SWP emulation enabled, leading to deadlock of the user
	  application.

	  NOTE: when accessing uncached shared regions, LDXR/STXR rely
	  on an external transaction monitoring block called a global
	  monitor to maintain update atomicity. If your system does not
	  implement a global monitor, this option can cause programs that
	  perform SWP operations to uncached memory to deadlock.

	  If unsure, say Y

config CP15_BARRIER_EMULATION
	bool "Emulate CP15 Barrier instructions"
	help
	  The CP15 barrier instructions - CP15ISB, CP15DSB, and
	  CP15DMB - are deprecated in ARMv8 (and ARMv7). It is
	  strongly recommended to use the ISB, DSB, and DMB
	  instructions instead.

	  Say Y here to enable software emulation of these
	  instructions for AArch32 userspace code. When this option is
	  enabled, CP15 barrier usage is traced which can help
	  identify software that needs updating. This feature can be
	  controlled at runtime with the abi.cp15_barrier sysctl.

	  If unsure, say Y

config SETEND_EMULATION
	bool "Emulate SETEND instruction"
	help
	  The SETEND instruction alters the data-endianness of the
	  AArch32 EL0, and is deprecated in ARMv8.

	  Say Y here to enable software emulation of the instruction
	  for AArch32 userspace code. This feature can be controlled
	  at runtime with the abi.setend sysctl.

	  Note: All the cpus on the system must have mixed endian support at EL0
	  for this feature to be enabled. If a new CPU - which doesn't support mixed
	  endian - is hotplugged in after this feature has been enabled, there could
	  be unexpected results in the applications.

	  If unsure, say Y
endif # ARMV8_DEPRECATED

endif # COMPAT

config ARM64_PSEUDO_NMI
	bool "Support for NMI-like interrupts"
	select ARM_GIC_V3
	help
	  Adds support for mimicking Non-Maskable Interrupts through the use of
	  GIC interrupt priority. This support requires version 3 or later of
	  ARM GIC.

	  This high priority configuration for interrupts needs to be
	  explicitly enabled by setting the kernel parameter
	  "irqchip.gicv3_pseudo_nmi" to 1.

	  If unsure, say N

if ARM64_PSEUDO_NMI
config ARM64_DEBUG_PRIORITY_MASKING
	bool "Debug interrupt priority masking"
	help
	  This adds runtime checks to functions enabling/disabling
	  interrupts when using priority masking. The additional checks verify
	  the validity of ICC_PMR_EL1 when calling concerned functions.

	  If unsure, say N
endif # ARM64_PSEUDO_NMI

config RELOCATABLE
	bool "Build a relocatable kernel image" if EXPERT
	select ARCH_HAS_RELR
	default y
	help
	  This builds the kernel as a Position Independent Executable (PIE),
	  which retains all relocation metadata required to relocate the
	  kernel binary at runtime to a different virtual address than the
	  address it was linked at.
	  Since AArch64 uses the RELA relocation format, this requires a
	  relocation pass at runtime even if the kernel is loaded at the
	  same address it was linked at.

config RANDOMIZE_BASE
	bool "Randomize the address of the kernel image"
	select RELOCATABLE
	help
	  Randomizes the virtual address at which the kernel image is
	  loaded, as a security feature that deters exploit attempts
	  relying on knowledge of the location of kernel internals.

	  It is the bootloader's job to provide entropy, by passing a
	  random u64 value in /chosen/kaslr-seed at kernel entry.

	  When booting via the UEFI stub, it will invoke the firmware's
	  EFI_RNG_PROTOCOL implementation (if available) to supply entropy
	  to the kernel proper. In addition, it will randomise the physical
	  location of the kernel Image as well.

	  If unsure, say N.

config RANDOMIZE_MODULE_REGION_FULL
	bool "Randomize the module region over a 2 GB range"
	depends on RANDOMIZE_BASE
	default y
	help
	  Randomizes the location of the module region inside a 2 GB window
	  covering the core kernel. This way, it is less likely for modules
	  to leak information about the location of core kernel data structures
	  but it does imply that function calls between modules and the core
	  kernel will need to be resolved via veneers in the module PLT.

	  When this option is not set, the module region will be randomized over
	  a limited range that contains the [_stext, _etext] interval of the
	  core kernel, so branch relocations are almost always in range unless
	  the region is exhausted. In this particular case of region
	  exhaustion, modules might be able to fall back to a larger 2GB area.

config CC_HAVE_STACKPROTECTOR_SYSREG
	def_bool $(cc-option,-mstack-protector-guard=sysreg -mstack-protector-guard-reg=sp_el0 -mstack-protector-guard-offset=0)

config STACKPROTECTOR_PER_TASK
	def_bool y
	depends on STACKPROTECTOR && CC_HAVE_STACKPROTECTOR_SYSREG

config UNWIND_PATCH_PAC_INTO_SCS
	bool "Enable shadow call stack dynamically using code patching"
	# needs Clang with https://github.com/llvm/llvm-project/commit/de07cde67b5d205d58690be012106022aea6d2b3 incorporated
	depends on CC_IS_CLANG && CLANG_VERSION >= 150000
	depends on ARM64_PTR_AUTH_KERNEL && CC_HAS_BRANCH_PROT_PAC_RET
	depends on SHADOW_CALL_STACK
	select UNWIND_TABLES
	select DYNAMIC_SCS

config ARM64_CONTPTE
	bool "Contiguous PTE mappings for user memory" if EXPERT
	depends on TRANSPARENT_HUGEPAGE
	default y
	help
	  When enabled, user mappings are configured using the PTE contiguous
	  bit, for any mappings that meet the size and alignment requirements.
	  This reduces TLB pressure and improves performance.

endmenu # "Kernel Features"

menu "Boot options"

config ARM64_ACPI_PARKING_PROTOCOL
	bool "Enable support for the ARM64 ACPI parking protocol"
	depends on ACPI
	help
	  Enable support for the ARM64 ACPI parking protocol. If disabled
	  the kernel will not allow booting through the ARM64 ACPI parking
	  protocol even if the corresponding data is present in the ACPI
	  MADT table.

config CMDLINE
	string "Default kernel command string"
	default ""
	help
	  Provide a set of default command-line options at build time by
	  entering them here. As a minimum, you should specify the the
	  root device (e.g. root=/dev/nfs).

choice
	prompt "Kernel command line type" if CMDLINE != ""
	default CMDLINE_FROM_BOOTLOADER
	help
	  Choose how the kernel will handle the provided default kernel
	  command line string.

config CMDLINE_FROM_BOOTLOADER
	bool "Use bootloader kernel arguments if available"
	help
	  Uses the command-line options passed by the boot loader. If
	  the boot loader doesn't provide any, the default kernel command
	  string provided in CMDLINE will be used.

config CMDLINE_FORCE
	bool "Always use the default kernel command string"
	help
	  Always use the default kernel command string, even if the boot
	  loader passes other arguments to the kernel.
	  This is useful if you cannot or don't want to change the
	  command-line options your boot loader passes to the kernel.

endchoice

config EFI_STUB
	bool

config EFI
	bool "UEFI runtime support"
	depends on OF && !CPU_BIG_ENDIAN
	depends on KERNEL_MODE_NEON
	select ARCH_SUPPORTS_ACPI
	select LIBFDT
	select UCS2_STRING
	select EFI_PARAMS_FROM_FDT
	select EFI_RUNTIME_WRAPPERS
	select EFI_STUB
	select EFI_GENERIC_STUB
	imply IMA_SECURE_AND_OR_TRUSTED_BOOT
	default y
	help
	  This option provides support for runtime services provided
	  by UEFI firmware (such as non-volatile variables, realtime
	  clock, and platform reset). A UEFI stub is also provided to
	  allow the kernel to be booted as an EFI application. This
	  is only useful on systems that have UEFI firmware.

config DMI
	bool "Enable support for SMBIOS (DMI) tables"
	depends on EFI
	default y
	help
	  This enables SMBIOS/DMI feature for systems.

	  This option is only useful on systems that have UEFI firmware.
	  However, even with this option, the resultant kernel should
	  continue to boot on existing non-UEFI platforms.

endmenu # "Boot options"

menu "Power management options"

source "kernel/power/Kconfig"

config ARCH_HIBERNATION_POSSIBLE
	def_bool y
	depends on CPU_PM

config ARCH_HIBERNATION_HEADER
	def_bool y
	depends on HIBERNATION

config ARCH_SUSPEND_POSSIBLE
	def_bool y

endmenu # "Power management options"

menu "CPU Power Management"

source "drivers/cpuidle/Kconfig"

source "drivers/cpufreq/Kconfig"

endmenu # "CPU Power Management"

source "drivers/acpi/Kconfig"

source "arch/arm64/kvm/Kconfig"

